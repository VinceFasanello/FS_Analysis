---
title: "FA_Prepare_Datasets"
output: html_notebook
---

Prepare the fitness assay datasets from raw counts data from 500-generation flux exp evo project fitness assays (gen-0 and gen-500)

***
# Setup Script
Prepare the workspace set global options, load packages, set directories, etc..
```{r}
rm(list=ls()) # clear workspace
knitr::opts_chunk$set(tidy = TRUE) # set global knitr options.
options(scipen = 999) # turn off scientific notation
require(plyr, quietly = T) # load required packages
dir_in_1 <- paste0(getwd(),"/Counts_Data/Library_1") # input: library 1 data
dir_in_2 <- paste0(getwd(),"/Counts_Data/Library_2") # input: library 2 data
dir_out_c <- paste0(getwd(),"/Counts_Data/Combined") # output: compbined library 1 and 2 data
dir_in_m <- paste0(getwd(),"/Metadata") # input: metadata
dir_out_f <- paste0(getwd(),"/Formatted_Data") # output: dataframe formatted for analysis

```
<br/><br/>



***
# Combine FA library 1 and FA library 2 data. 
Load and prepare the shared metadata file
```{r}
setwd("..")
setwd(dir_in_m)
lay <- read.csv("Layout.csv", header = T, stringsAsFactors = F)
```

Load and prepare the library 1 counts data
```{r}
setwd("..")
setwd(dir_in_1)
load(file = "counts.expected.Rdata") # expected counts
ec1 <- counts.expected; rm(counts.expected)
ec1 <- t(ec1) # transpose to match metadata format: experiments are rows

load(file = "counts.unexpected.Rdata") # unexpected counts (barcode cross contamination)
uc1 <- counts.unexpected; rm(counts.unexpected)
uc1 <- t(uc1) # transpose to match metadata format: experiments are rows
```


Load and prepare the library 2 counts data
```{r}
setwd("..")
setwd(dir_in_2)
load(file = "counts.expected.Rdata") # expected counts
ec2 <- counts.expected; rm(counts.expected)
ec2 <- t(ec2) # transpose to match metadata format: experiments are rows

load(file = "counts.unexpected.Rdata") # unexpected counts (barcode cross contamination)
uc2 <- counts.unexpected; rm(counts.unexpected)
uc2 <- t(uc2) # transpose to match metadata format: experiments are rows
```


Sum the library 1 and library 2 data by entry to create a combined dataset
```{r}
setwd("..")
setwd(dir_out_c)
ec <- ec1 + ec2 + 1 # expected counts = expected counts lib 1 + expected counts lib 2 + 1 pseudocount (for math handling downstream)
uc <- uc1 + uc2 + 1 # unexpected counts = unexpected counts lib 1 + unexpected counts lib 2 + 1 pseudocount (so that cross-contam is not artificially underreported due to ec pseudocount)
save(ec, file =  "ec.combined.Rdata")
save(uc, file =  "uc.combined.Rdata")
rm(ec1, ec2, uc1, uc2) # individual datasets are no longer needed.
```


Combine metadata with counts data
```{r}
myd <- cbind(lay, ec)

temp <- myd[which(myd$sample.type == "MPA_Plate"),]
temp <- unlist(myd[125:237])
hist(temp, breaks = 100)
hist(temp[temp < 10000], breaks = 100)
hist(temp[temp < 1000], breaks = 100)
hist(temp[temp < 200], breaks = 100)
hist(temp[temp < 50], breaks = 100); abline(v=15)

myd$ppects <- rowSums(ec, na.rm = T) # primer pair expected counts  *BLANKS WILL BE ZERO HERE!!!!*
myd$ppccts <- rowSums(uc, na.rm = T) # primer pair cross-contam counts *THESE ONLY MAKE SENSE FOR SINGLE WELL CONTROLS!!!*
rm(lay, ec, uc)
```


Calculate primer pair summary statistics for the only 5 available samples
```{r}
myd$cc <- (myd$ppccts / (myd$ppects + myd$ppccts)) 
myd$cc[6:nrow(myd)] <- NA
```


Split out datasets of interest and save. Will procede working only with the actual FA data (no control wells, searches, or blanks included)
```{r}
setwd("..")
setwd(dir_out_f)

# read on cross contam
swref <- myd[myd$sample.type == "SW_Ref",] # sequence of wells containing only the reference strain run through the fitness assay, for cross contamination estimation. 
save(swref, file = "swref.Rdata")

# controls...
growblnk <- myd[myd$sample.type == "Growth_Blank",] # Fitness assay growth blanks (no yeast added, should be sequenced media only)
save(growblnk, file = "growblnk.Rdata")
dnablnk <- myd[myd$sample.type == "DNA_Blank",] # dna blank -- samples processed through full processing with DNA free water added instead of resuspended yeast
save(dnablnk, file = "dnablnk.Rdata")
pcrblnk <- myd[myd$sample.type == "PCR_Blank",] # pcr blanks -- samples from every round of pcr -- included all components necessary for replication other than yeast DNA 
save(pcrblnk, file = "pcrblnk.Rdata")

# sw search for admin use.
swsearch <- myd[myd$sample.type == "SW_Search",] # Check samples run to hunt down the genetic barcode sequence in a few strains with incorrect sequences inserted. 
save(swsearch, file = "swsearch.Rdata")

rm(swref, growblnk, dnablnk, pcrblnk, swsearch)
# ------------------------------------------------
myd <-  myd[myd$sample.type == "MPA_Plate",] # the data for processing
```




***
# Process the fitness assay data for analysis and visualization.  
Create, arrange, and populate columns for barcode ID and barcode counts for all barcodes present in each pp.
```{r}
my <- myd
for (i in 1:113) { # create columns for barcode counts in form (bc#cts) for 1:23
  my[,paste0("bc", i, "cts")] <- NA 
}

colnames(my)[which(colnames(my) == "barcode.1")] <- "ref" # name bc1 to reference columns 
colnames(my)[which(colnames(my) == "bc1cts")] <- "refcts" # same for the counts

for (i in 1:nrow(my)) { # for each primer pair....
  my$refcts[i] <- my[i,which(colnames(my) == my$ref[i])] # populate the ref counts cell.
  for (j in 2:113) { # for each other barcode j...
    if  (!is.na(my[i, paste0("barcode.", j)])){ # if there is a barcode j in this pp...
      my[i,paste0("bc", j, "cts")] <-  my[i,which(colnames(my) == my[i, paste0("barcode.", j)])] # populate the bcjcts cell with counts from the corresponding column for bcj.
    } else { # if there is not a barcode j in this pp....
      my[i,paste0("bc", j, "cts")] <- NA # populate the bcjcts cell with an NA value (for now)
    }
  }
}

my <- my[,c(1,6:124, 241:353, 238, 239)] # omit columns that are no longer needed
myd <- my # pass the cleaned up dataframe back to myfa
```
<br/><br/>



Convert the one-pp-per-row dataset to a dataset format with data for a single barcode (at a single fitness assay timepoint) (at either generation 0 or gereration 250) per row.
```{R}
my <- myd 
myttg <- NA # start the new dataframe, this is where we will grow the one well per row dataset. 
for(i in 1:nrow(my)){ # for each row in my...
  myt <- my[i,] # make that row a new dataset
  j <- 9 # set j to 16 (start column number)
  while(j<65){ # while j is less than the index one past the last starting barcode for a pair...
      mytt <- myt[c(1:7, 234, 235, 8, 121, j, j+113, j+56, j+169)] # create a dataset with all metadata, and the data for just that pair
      colnames(mytt)[c(12:15)] <- c("bc1", "bc1cts", "bc2", "bc2cts") # fix colum names
      myttg <- rbind(myttg, mytt) # append to the growing dataframe
      j <- j+1 # increment j
  }
}
my <- myttg # pass the dataframe back to my
my <- my[!is.na(my$bc1),] # remove na entries (fully multiplexed dataset, so this will only remove the NA entry at the top that was used as the dataframe seed.)
my$wo <- 1 # well order (for symoatric pairs)
my <- my[,c(1:7, 16, 8:15)] # rearrange columns
my2 <- my[,c(1:12, 15, 16, 13, 14)]  # create a my2 dataframe with barcode 2 as barcode 1 (so we can have one fitness value per row at the end)
my2$wo <- 2 # update the well order field in this new dataset
colnames(my2) <- colnames(my) # fix column names to match my
my <- rbind(my, my2) # rowbind the two datasets. 
my <- my[,c(2:7, 11, 13, 15, 9, 10, 12, 14, 16)]# omit and reorder columns to make next steps easier
myd <- my # pass to myfa
rm(my, my2, myt, mytt, myttg) # clean up. 
```
<br/><br/>



Subset myfa into datasets corresponding to fitness assay initial and fitness assay final timepoints, then combine these datasets into a single dataframe such that each row includes initial and final timepoint data for a single barcode at either generation 0 or generation 500.
```{R}
my <- myd

# NOTE: atp 0 and atp 2 timepoints are not paired! AND there are 5 reps at atp 0 while only 4 reps at atp 2. This need special handing. 

# First: subset for fitness assay time point 0 (initial mixtures)
my0 <- my[my$atp == 0,] # subset 
my0$id <- paste0(my0$epo, my0$etp, my0$bc1, my0$bc2) # append informative ids
my0 <- my0[ , !names(my0) %in% c("atp","mpamt", "mpasp")]# remove unneccessary columns
my0 <- my0[,c(ncol(my0), 1:(ncol(my0)-1))] # reorder so id is in the front
# Second: split out dataframes for reps 1:5 within the atp0 data
my0r1 <- my0[my0$mpar == 1,] # subset...
my0r2 <- my0[my0$mpar == 2,]
my0r3 <- my0[my0$mpar == 3,]
my0r4 <- my0[my0$mpar == 4,]
my0r5 <- my0[my0$mpar == 5,]
# Third: Fix column names for binding
colnames(my0r1)[c(8:12)] <- paste0(colnames(my0r1)[c(8:12)], "_r1i") # fixing names...
colnames(my0r2)[c(8:12)] <- paste0(colnames(my0r2)[c(8:12)], "_r2i")
colnames(my0r3)[c(8:12)] <- paste0(colnames(my0r3)[c(8:12)], "_r3i")
colnames(my0r4)[c(8:12)] <- paste0(colnames(my0r4)[c(8:12)], "_r4i")
colnames(my0r5)[c(8:12)] <- paste0(colnames(my0r5)[c(8:12)], "_r5i")
sum(my0r1$id != my0r2$id); sum(my0r1$id != my0r3$id); sum(my0r1$id != my0r4$id); sum(my0r1$id != my0r5$id) # Check sort order before binding. 
my0 <- cbind(my0r1, my0r2[,c(8:12)], my0r3[,c(8:12)], my0r4[,c(8:12)], my0r5[,c(8:12)]) # bind the metadata with the data columns from each subset 1:5
rm(my0r1, my0r2, my0r3, my0r4, my0r5)
# -----

my2 <- my[my$atp == 2,] # subset for fitness assay day f (final overnight cultures)
my2$id <- paste0(my2$epo, my2$etp, my2$bc1, my2$bc2) # append informative ids
my2 <- my2[,c(ncol(my2), 1:(ncol(my2)-1))] # reorder so id is in the front
colnames(my2)[c(11:15)] <- paste0(colnames(my2)[c(11:15)], "_f") # fixing names...

my2t <- NA # initialize the temporary dataframe
for(i in 1:nrow(my2)){ # want our output table to have the same number of rows as my2, just appending info based on id.
  my2tt <- my2[i,] # take a single row
  my0tt <- my0[my0$id == my2tt$id,] # find the corresponding mpa 0 data
  my2tt <- cbind(my2tt, my0tt[8:32]) # append the data columns for reps 1:5
  my2t <- rbind(my2t, my2tt) # bind to the end of the growin goutput dataframe
}
myd <- my2t[2:nrow(my2t),] # myd is the fitness dataframe...but we will want to work on the deltafit dataframe.
rm(my, my0, my2, my2t, my2tt, my0tt)
```
<br/><br/>





Repeat but now want a single row for the change in fitness for each barcode in each env. so one entry for each evo gen 500 row in the current myd dataframe
```{R}
my <- myd

# NOTE: etp 000 and etp 500 timepoints are not paired! AND there are 4 reps of each. 

# First: deal with gen 000 dataset.
my000 <- my[my$etp == 0,] # subset 
my000$id <- paste0( my000$mpamt, my000$mpasp, my000$bc1, my000$bc2) # append informative ids
my000 <- my000[ , !names(my000) %in% c("epo","atp","etp", "mpamt", "mpasp", "ref", "bc1", "bc2")]# remove unneccessary columns

# Second: split out dataframes for reps 1:4 within the 000 dataframe
my000r1 <- my000[my000$mpar == 1,] # subset...
my000r2 <- my000[my000$mpar == 2,]
my000r3 <- my000[my000$mpar == 3,]
my000r4 <- my000[my000$mpar == 4,]

# Third: Fix column names for binding
colnames(my000r1)[c(3:7)] <- paste0(colnames(my000r1)[c(3:7)], "_r1a") # fixing names...
colnames(my000r1)[c(8:32)] <- paste0(colnames(my000r1)[c(8:32)], "_a") # fixing names...
colnames(my000r2)[c(3:7)] <- paste0(colnames(my000r2)[c(3:7)], "_r2a") 
colnames(my000r3)[c(3:7)] <- paste0(colnames(my000r3)[c(3:7)], "_r3a") 
colnames(my000r4)[c(3:7)] <- paste0(colnames(my000r4)[c(3:7)], "_r4a") 
sum(my000r1$id != my000r2$id); sum(my000r1$id != my000r3$id); sum(my000r1$id != my000r4$id) # Check sort order before binding. 
my000 <- cbind(my000r1[,c(1, 8:32)], my000r1[,c(3:7)], my000r2[,c(3:7)], my000r3[,c(3:7)], my000r4[,c(3:7)]) # bind the metadata with the data columns from each subset 1:4
rm(my000r1, my000r2, my000r3, my000r4)
# -----

my500 <- my[my$etp == 500,] # subset for fitness assay day f (final overnight cultures)
my500$id <- paste0( my500$mpamt, my500$mpasp, my500$bc1, my500$bc2) # append informative ids
colnames(my500)[c(11:40)] <- paste0(colnames(my500)[c(11:40)], "_e") # fixing names...

my500t <- NA # initialize the temporary dataframe
for(i in 1:nrow(my500)){ # want our output table to have the same number of rows as my500, just appending info based on id.
  my500tt <- my500[i,] # take a single row
  my000tt <- my000[my000$id == my500tt$id,] # find the corresponding 000 data
  my500tt <- cbind(my500tt, my000tt[2:46]) # append the data columns for reps 1:4
  my500t <- rbind(my500t, my500tt) # bind to the end of the growin goutput dataframe
}
my500t <- my500t[ , !names(my500t) %in% c("etp", "atp", "id")]# remove unneccessary columns
myd <- my500t[2:nrow(my500t),] # myd is the fitness dataframe...but we will want to work on the deltafit dataframe.
rm(my, my000, my500, my500t, my500tt, my000tt)
```
<br/><br/>


Add treatment info [this requires outside knowledge of which barcodes were in which treatments -- from the experimental design]
```{R}
my <- myd
my$treat <- NA
my$min <- NA # add quantitative info as well for calcs down the line that we may want. 
my$max <- NA

# setup some lists of Barcode IDs and their corresponding treatmnets and assign with quant info attached.
# 0% stress, Uniform
EH0 <- c("d1B12", "d2B12", "d1B1", "d2B1",  "d1C1", "d2C1",  "d1D1", "d2D1", 
         "d1E1", "d2E1",  "d1F1", "d2F1",  "d1G1", "d2G1", "d1C12", "d2C12")
my[my$bc1 %in% EH0, c("treat", "min", "max")] <- c(rep("EH0", times = nrow(my[my$bc1 %in% EH0,])),
                                                   rep(0, times = nrow(my[my$bc1 %in% EH0,])),
                                                   rep(0, times = nrow(my[my$bc1 %in% EH0,])))
# 40% stress, Uniform
EH40 <- c("d1A3", "d2A3", "d1B3", "d2B3", "d1C3", "d2C3", "d1D3", "d2D3",
          "d1E3", "d2E3", "d1F3", "d2F3", "d1G3", "d2G3", "d1H3", "d2H3")
my[my$bc1 %in% EH40, c("treat", "min", "max")] <- c(rep("EH40", times = nrow(my[my$bc1 %in% EH40,])),
                                                   rep(40, times = nrow(my[my$bc1 %in% EH40,])),
                                                   rep(40, times = nrow(my[my$bc1 %in% EH40,])))
# 80% stress, Uniform
EH80 <- c("d1G12", "d2G12", "d1B5", "d2B5", "d1C5", "d2C5", "d1D5", "d2D5",
          "d1E5", "d2E5", "d1F5", "d2F5", "d1G5", "d2G5", "d1H5", "d2H5")
my[my$bc1 %in% EH80, c("treat", "min", "max")] <- c(rep("EH80", times = nrow(my[my$bc1 %in% EH80,])),
                                                   rep(80, times = nrow(my[my$bc1 %in% EH80,])),
                                                   rep(80, times = nrow(my[my$bc1 %in% EH80,])))
# 0/40% stress, Fluctuating
EH0.40 <- c("d1A7", "d2A7", "d1B7", "d2B7", "d1C7", "d2C7", "d1D7", "d2D7",
            "d1E7", "d2E7", "d1F7", "d2F7", "d1G7", "d2G7", "d1H7", "d2H7")
my[my$bc1 %in% EH0.40, c("treat", "min", "max")] <- c(rep("EH0_40", times = nrow(my[my$bc1 %in% EH0.40,])),
                                                   rep(0, times = nrow(my[my$bc1 %in% EH0.40,])),
                                                   rep(40, times = nrow(my[my$bc1 %in% EH0.40,])))
# 0/80% stress, Fluctuating
EH0.80 <- c("d1A9", "d2A9", "d1B9", "d2B9", "d1C9", "d2C9", "d1D9", "d2D9",
            "d1E9", "d2E9", "d1F9", "d2F9", "d1G9", "d2G9", "d1H9", "d2H9")
my[my$bc1 %in% EH0.80, c("treat", "min", "max")] <- c(rep("EH0_80", times = nrow(my[my$bc1 %in% EH0.80,])),
                                                   rep(0, times = nrow(my[my$bc1 %in% EH0.80,])),
                                                   rep(80, times = nrow(my[my$bc1 %in% EH0.80,])))
# 20/60% stress, Fluctuating
EH20.60 <- c("d1A10", "d2A10", "d1B10", "d2B10", "d1C10", "d2C10", "d1D10",
             "d2D10", "d1E10", "d2E10", "d1F10", "d2F10", "d1G10", "d2G10", 
             "d1H10", "d2H10")
my[my$bc1 %in% EH20.60, c("treat", "min", "max")] <- c(rep("EH20_60", times = nrow(my[my$bc1 %in% EH20.60,])),
                                                   rep(20, times = nrow(my[my$bc1 %in% EH20.60,])),
                                                   rep(60, times = nrow(my[my$bc1 %in% EH20.60,])))
# 40/80% stress, Fluctuating 
EH40.80 <- c("d1A11", "d2A11", "d1B11", "d2B11", "d1C11","d2C11", "d1D11", 
             "d2D11", "d1E11", "d2E11", "d1F11", "d2F11", "d1G11", "d2G11", 
             "d1H11", "d2H11")
my[my$bc1 %in% EH40.80, c("treat", "min", "max")] <- c(rep("EH40_80", times = nrow(my[my$bc1 %in% EH40.80,])),
                                                   rep(40, times = nrow(my[my$bc1 %in% EH40.80,])),
                                                   rep(80, times = nrow(my[my$bc1 %in% EH40.80,])))
myd <- my
```
<br/><br/>

We will want some unique identifiers for our models later....Lets make three types
#1 Need an identifier for replicates of the same barcode fitness in the same test env --- USE THIS ONE FOR ANALYSIS
```{R}
# use bc1 column times the evo plate origin (to keep plates A and B seperate)
my <- myd
my$bcpID <- as.factor(paste0(my$bc1, my$epo))
myd <- my
```
<br/><br/>

#2 Add an identifier that ignores evo plate origin and groups based only on MOBY bcID -- NOT CURRENTLY USED (But could be of interest.)
```{R}
# use bc1 column times the evo plate origin (to keep plates A and B seperate)
my <- myd
my$bcID <- as.factor(my$bc1)
myd <- my
```


#3 Add a field to store the well id of each entry -- this will ensure that entries for [bc1, bc2] and those for [bc2, bc1] for each evolutionary well can be recognized as coming from the same evolutionary well (i.e., identifier for pairs that evolved in sympatry). -- NOT CURRENTLY USED (but could be of intereset.)
```{R}
my <- myd
my$well <- NA
my$t1 <- NA # barcode 1 id
my$t2 <- NA # barcode 2 id
for(i in 1:nrow(my)){  # for each row in the dataframe...
  my$t1[i] <- paste(sort(my[i,c("bc1", "bc2")])[1]) # barcode 1 id is the firt entry when sorted
  my$t2[i] <- paste(sort(my[i,c("bc1", "bc2")])[2]) # barcode 2 id is the second entry when sorted
} 
my$well <- paste0(my$t1, my$t2) # well is ordered concatonation of t1, t2 entries
my <- my[,1:(ncol(my) - 2)] # remove the t1, t2 columns, they are no longer needed. 
myd <- my # pass to myfa
```
<br/><br/>


Add reads
```{R}
my <- myd
# reads for gen 0 fitness assay initial timepoint, harmonic mean of bc reads, ref reads, and total expected reads for the sample.
my$re_r1i_a <- 3/((1/my$bc1cts_r1i_a)+(1/my$refcts_r1i_a)+(1/my$ppects_r1i_a)) # gen 0, mpa = i, r1
my$re_r2i_a <- 3/((1/my$bc1cts_r2i_a)+(1/my$refcts_r2i_a)+(1/my$ppects_r2i_a)) # gen 0, mpa = i, r2
my$re_r3i_a <- 3/((1/my$bc1cts_r3i_a)+(1/my$refcts_r3i_a)+(1/my$ppects_r3i_a)) # gen 0, mpa = i, r3
my$re_r4i_a <- 3/((1/my$bc1cts_r4i_a)+(1/my$refcts_r4i_a)+(1/my$ppects_r4i_a)) # gen 0, mpa = i, r4
my$re_r5i_a <- 3/((1/my$bc1cts_r5i_a)+(1/my$refcts_r5i_a)+(1/my$ppects_r5i_a)) # gen 0, mpa = i, r5
my$re_i_a <- rowMeans(cbind(my$re_r1i_a, my$re_r2i_a, my$re_r3i_a, my$re_r4i_a, my$re_r5i_a)) # Summary reads: gen 0, mpa i, r1:r5

# reads for gen 0 fitness assay final timepoint, harmonic mean of bc reads, ref reads, and total expected reads for the sample.
my$re_f_r1a <- 3/((1/my$bc1cts_f_r1a)+(1/my$refcts_f_r1a)+(1/my$ppects_f_r1a)) # gen 0, mpa = f, r1
my$re_f_r2a <- 3/((1/my$bc1cts_f_r2a)+(1/my$refcts_f_r2a)+(1/my$ppects_f_r2a)) # gen 0, mpa = f, r2
my$re_f_r3a <- 3/((1/my$bc1cts_f_r3a)+(1/my$refcts_f_r3a)+(1/my$ppects_f_r3a)) # gen 0, mpa = f, r3
my$re_f_r4a <- 3/((1/my$bc1cts_f_r4a)+(1/my$refcts_f_r4a)+(1/my$ppects_f_r4a)) # gen 0, mpa = f, r4

# reads for gen 0 fitness
my$re_fit_r1a <- 2/((1/my$re_i_a)+(1/my$re_f_r1a)) # gen 0, r1
my$re_fit_r2a <- 2/((1/my$re_i_a)+(1/my$re_f_r2a)) # gen 0, r2
my$re_fit_r3a <- 2/((1/my$re_i_a)+(1/my$re_f_r3a)) # gen 0, r3
my$re_fit_r4a <- 2/((1/my$re_i_a)+(1/my$re_f_r4a)) # gen 0, r4
my$re_fit_a <- rowMeans(cbind(my$re_fit_r1a, my$re_fit_r2a, my$re_fit_r3a, my$re_fit_r4a)) # Summary reads: ancestral fitness

# reads for gen 500 fitness assay initial timepoint, harmonic mean of bc reads, ref reads, and total expected reads for the sample.
my$re_r1i_e <- 3/((1/my$bc1cts_r1i_e)+(1/my$refcts_r1i_e)+(1/my$ppects_r1i_e)) # gen 500, mpa = i, r1
my$re_r2i_e <- 3/((1/my$bc1cts_r2i_e)+(1/my$refcts_r2i_e)+(1/my$ppects_r2i_e)) # gen 500, mpa = i, r2
my$re_r3i_e <- 3/((1/my$bc1cts_r3i_e)+(1/my$refcts_r3i_e)+(1/my$ppects_r3i_e)) # gen 500, mpa = i, r3
my$re_r4i_e <- 3/((1/my$bc1cts_r4i_e)+(1/my$refcts_r4i_e)+(1/my$ppects_r4i_e)) # gen 500, mpa = i, r4
my$re_r5i_e <- 3/((1/my$bc1cts_r5i_e)+(1/my$refcts_r5i_e)+(1/my$ppects_r5i_e)) # gen 500, mpa = i, r5
my$re_i_e <- rowMeans(cbind(my$re_r1i_e, my$re_r2i_e, my$re_r3i_e, my$re_r4i_e, my$re_r5i_e)) # Summary reads: gen 500, mpa i, r1:r5

# reads for gen 500 fitness assay final timepoint, harmonic mean of bc reads, ref reads, and total expected reads for the sample.
my$re_f_e <-  3/((1/my$bc1cts_f_e)+(1/my$refcts_f_e)+(1/my$ppects_f_e)) # gen 500, mpa = f

# reads for gen 500 fitness
my$re_fit_e <- 2/((1/my$re_i_e)+(1/my$re_f_e)) # gen 500

# reads for deltafitness
my$re_dw <- 2/((1/my$re_fit_a)+(1/my$re_fit_e)) # gen 500 - gen 0
myd <- my
```



Calculate fitness at generation-0 and generation-250; calculate change in fitness from gen-0 to gen-250 for each row. 
```{R}
my <- myd
# First need to calculate fitness of the ancestral yeast...this is a multistep process
# calculate average bc1cts and refcts for ancestral mpa timepoint i reps r1:r5; weight by reads
my$bc1cts_i_a <- apply(my, 1, function(x) weighted.mean(as.numeric(x[c( "bc1cts_r1i_a", "bc1cts_r2i_a", "bc1cts_r3i_a", "bc1cts_r4i_a", "bc1cts_r5i_a")]), 
                                                  as.numeric(x[c( "re_r1i_a", "re_r2i_a", "re_r3i_a", "re_r4i_a", "re_r5i_a")])))
my$refcts_i_a <- apply(my, 1, function(x) weighted.mean(as.numeric(x[c( "refcts_r1i_a", "refcts_r2i_a", "refcts_r3i_a", "refcts_r4i_a", "refcts_r5i_a")]), 
                                                  as.numeric(x[c( "re_r1i_a", "re_r2i_a", "re_r3i_a", "re_r4i_a", "re_r5i_a")])))

# Calculate fitness for ancestral yeast
my$fit0r1 <- exp((log(my$bc1cts_f_r1a/my$refcts_f_r1a) - log(my$bc1cts_i_a/my$refcts_i_a))/20) # rep 1
my$fit0r2 <- exp((log(my$bc1cts_f_r2a/my$refcts_f_r2a) - log(my$bc1cts_i_a/my$refcts_i_a))/20) # rep 2
my$fit0r3 <- exp((log(my$bc1cts_f_r3a/my$refcts_f_r3a) - log(my$bc1cts_i_a/my$refcts_i_a))/20) # rep 3
my$fit0r4 <- exp((log(my$bc1cts_f_r4a/my$refcts_f_r4a) - log(my$bc1cts_i_a/my$refcts_i_a))/20) # rep 4

# calculate mean ancestral fitness; weight by reads for fit r1:r4
my$fit0 <- apply(my, 1, function(x) weighted.mean(as.numeric(x[c( "fit0r1", "fit0r2", "fit0r3", "fit0r4")]), 
                                                  as.numeric(x[c( "re_fit_r1a", "re_fit_r2a", "re_fit_r3a", "re_fit_r4a")])))
#---------


# Second need to calculate fitness for evolved yeast...should be easy
# Caclulate average bc1cts and refcts for evolved mpa timepoint i reps r1:r5; weight by reads
my$bc1cts_i_e <- apply(my, 1, function(x) weighted.mean(as.numeric(x[c( "bc1cts_r1i_e", "bc1cts_r2i_e", "bc1cts_r3i_e", "bc1cts_r4i_e", "bc1cts_r5i_e")]), 
                                                  as.numeric(x[c( "re_r1i_e", "re_r2i_e", "re_r3i_e", "re_r4i_e", "re_r5i_e")])))
my$refcts_i_e <- apply(my, 1, function(x) weighted.mean(as.numeric(x[c( "refcts_r1i_e", "refcts_r2i_e", "refcts_r3i_e", "refcts_r4i_e", "refcts_r5i_e")]), 
                                                  as.numeric(x[c( "re_r1i_e", "re_r2i_e", "re_r3i_e", "re_r4i_e", "re_r5i_e")])))

# Calculate fitness
my$fit500 <- exp((log(my$bc1cts_f_e/my$refcts_f_e) - log(my$bc1cts_i_e/my$refcts_i_e))/20)
#---------


# Third need to calculate deltafitness, dw
my$dw <- my$fit500 - my$fit0
myd <- my
```
<br/><br/>



Remomve problem entries. 
```{R}
my <- myd
# remove rows with bc1 id == "d2C5" and "d2C9", these barcodes share a barcode sequence and therefore cannot be analyzed in the pooled fitness assay. 
my <- my[my$bc1 != "d2C5" & my$bc1 != "d2C9",]
myd <- my # pass back to myfa
```
<br/><br/>



Add a field that marks whether bc's became extinct across 500 gens or not. 
DEFINITION: omit = average counts < 2 for generation 500 fitness assay initial timepoint (indicates that the bc was not really present at generation 500, extinct, therefore shouldn't have a fitness and shouldn't be plotted!)
```{R}
my <- myd
my$extinct <- FALSE
my$extinct[my$bc1cts_i_e < 15] <- TRUE
myd <- my
```
<br/><br/>


Update treatment field for ease of use. 
```{R}
my <- myd
my$treat <- as.factor(my$treat) # make treatment a factor
my$treat <- relevel(my$treat, ref = "EH0") # set the base level for treatment for future convenience
myd <- my
```
<br/><br/>


Finished processing the fitness assay data for analysis and visualization, save. 
```{R}
setwd("..")
setwd(dir_out_f)
save(myd, file = "myd.Rdata")
```
<br/><br/>